% !TeX root = induction-he.tex

\chapter{%
הוכחת נכונות של תכניות%
}\label{s.verif}

תכנית מחשב היא
\textbf{נכונה}
אם
\textbf{כל}
חישוב תואם את המפרט של התכנית. למשל, אם המפרט של תכנית דורש שהיא תחשב שורש ריבועי של מספר בקלט, אם התכנית מחשבת שורש שלישי, התכנית לא נכונה. אולם התכנית תהפוך לנכונה אם נשנה את המפרט כדי לדרוש חישוב של שורש שלישי. קיימות שיטות לכתיבת מפרטים פורמליים ושיטות
\textbf{להוכחה}
שתכנית עומדת בדרישות המפרט.

אין מגבלה על האורך )מספר הצעדים( של חישוב. כמו כן, אין מגבלה על מספר החישובים השונים שתכנית יכולה לבצע. תכנית לחישוב שורש תבצע חישוב שונה עבור כל מספר אפשרי בקלט. לכן, טבעי שמשתמשים באינדוקציה כדי להוכיח תכונות של תכניות עם אורך חישוב בלתי מוגבל ומספר חישובים בלתי מוגבל.

נדגים כאן הוכחות אינדוקטיביות של תכניות סדרתיות ותכניות מקביליות. תכנית סדרתית היא
\textbf{פונקציונלית}:
היא מקבלת קלט ומפיקה פלט במספר צעדים סופי. נדגים חישוב סדרתי על אלגוריתם למיון סדרת מספרים: הקלט הוא הסדרה והפלט הוא תמורה של הסדרה עם ערכיה בסדר עולה. נשתמש באינדוקציה כדי להוכיח את נכונות האלגוריתם ללא תלות בכמות המספרים בסדרה.

תכניות מקביליות מורכבות ממספר תכניות סדרתיות המכונות
\textbf{תהליכים}
המתבצעים בו-זמנית. בדרך כלל, תכניות מקביליות הן
\textbf{תגובתיות},
לא פונקציונליות: אנו מצפים שהן תתבצענה ללא נקודת סיום ותייצרנה פלט תוך זמן קצר מקבלת הקלט. למשל, מערכת ההפעלה של סמארטפון מתבצעת תמיד: כאשר אתה נוגע בצלמית מייד יש תגובה נראית. אינדוקציה היא חיונית בהוכחת נכונות של תכניות מקביליות, כי קיים מספר אינסופי של
\textbf{שילובים}
של החישובים של התהליכים המרכיבים את התכנית.

\section{%
תכניות סדרתיות%
}

נסתכל על מערך של מספרים שלמים כגון:%
\footnote{%
במדעי המחשב משתמשים במונח מערך עבור מה שמתמטיקאים קוראים וקטור.%
}
\[
A=[5,31,7,1,6,17,16,22,3,10]\,.
\]
דרוש אלגוריתם
\textbf{למיון}
המערך
$A$:
בנה מערך
$B$
שהאיברים שלו הם תמורה של האיברים של
$A$
בסדר עולה:
\[
B=[1,3,5,6,7,10,16,17,22,31]\,.
\]
נציג שני אלגוריתמים פשוטים למיון.
\paragraph{%
מיון הכנסה%
}

כאשר משחקים קלפים, שחקן אדיב יחכה עד שכל הקלפים חולקו ורק אחר כך יאסוף אותם ויסדר אותם. אם אתה לא אדיב אפשר להשתמש באלגוריתם יעיל המכונה מיון הכנסה: אסוף את הקלפים אחד-אחד והכנס אותם במקומם לפי הסדר:%
\footnote{%
השמטנו את הפקודות עבור המקרה שהקלף הוא קטן יותר מכל הקלפים שסודרו עד כה.%
}

\medskip

\hspace*{3em}%
כל עוד A אינו ריק\\
\hspace*{6em}%
קח את הערך הראשון ב-A והכנס לאחר הערך הגדול ביותר ב-B שקטן ממנו

\medskip
עבור המערך
$A$
לעיל, בניית המערך
$B$
מתנהלת כך:
\[
\begin{array}{lll}
B_0&=&[\,]\\
B_1&=&[5]\\
B_2&=&[5,31]\\
B_3&=&[5,7,31]\\
B_4&=&[1,5,7,31]\\
B_5&=&[1,5,6,7,31]\\
B_6&=&[1,5,6,7,17,31]\\
B_7&=&[1,5,6,7,16,17,31]\\
B_8&=&[1,5,6,7,16,17,22,31]\\
B_9&=&[1,3,5,6,7,16,17,22,31]\\
B_{10}&=&[1,3,5,6,7,10,16,17,22,31]\\
\end{array}
\begin{array}{lll}
A_0&=&[5,31,7,1,6,17,16,22,3,10]\\
A_1&=&[31,7,1,6,17,16,22,3,10]\\
A_2&=&[7,1,6,17,16,22,3,10]\\
A_3&=&[1,6,17,16,22,3,10]\\
A_4&=&[6,17,16,22,3,10]\\
A_5&=&[17,16,22,3,10]\\
A_6&=&[16,22,3,10]\\
A_7&=&[22,3,10]\\
A_8&=&[3,10]\\
A_9&=&[10]\\
A_{10}&=&[\,]\\
\end{array}
\]
נוכיח את הנכונות של מיון הכנסה עבור מערך
$A$
באורך שרירותי
$n$.

\textbf{%
טענת נכונות%
}
כאשר הביצוע של מיון הכנסה מסתיים, כל האיברים של
$B$
הם תמורה של האיברים של
$A$
בסדר עולה.

\textbf{%
למה %
1:}
לכל
$i$,
הסדרה המורכבת מהערכים של
$B_i$
ולאחריהם האיברים של
$A_i$
היא תמורה של
$A$.

\textbf{%
למה %
2:}
לכל
$i$,
האיברים ב-%
$B_i$
מסודרים בסדר עולה.

טענת הנכונות נובעת מיד מהלמות: כאשר החישוב מסתיים, 
$A_n$
ריקה, ולכן לפי למה~1, הסדרה
$B_n$
לבדה היא תמורה של האיברים של
$A$,
ולפי למה~2,
$B_n$
סדורה בסדר עולה.

לא נביא את ההוכחה הפשוטה של למה 1.

\textbf{%
הוכחת למה %
2:}
טענת בסיס: 
$B_0$
היא סדרה ריקה ולכן היא סדורה. צעד אינדוקטיבי: נניח כהנחת האינדוקציה ש-%
$B_i$
סדורה. יהי 
$a_i$
האיבר הראשון של
$A_i$
ו-%
$b_k$
האיבר הגדול ביותר של
$B_i$
כך ש-%
$b_k < a_i \leq b_{k+1}$. 
אזי
$B_{i+1} = [\ldots,b_k,a_i,b_{k+1},\ldots]$
היא סדרה סדורה.

\paragraph{%
מיון בחירה%
}

מיון בחירה הוא אלגוריתם פשוט שקל יותר לישום ממיון הכנסה:

\medskip

\hspace*{3em}%
כל עוד A אינו ריק\\
\hspace*{6em}%
קח את הערך הקטן ביותר של A ושרשר אותו לסוף B

\medskip

עבור המערך בדוגמה, החישוב הוא:
\[
\begin{array}{lll}
B_0&=&[\,]\\
B_1&=&[1]\\
B_2&=&[1,3]\\
B_3&=&[1,3,5]\\
B_4&=&[1,3,5,6]\\
B_5&=&[1,3,5,6,7]\\
B_6&=&[1,3,5,6,7,10]\\
B_7&=&[1,3,5,6,7,10,16]\\
B_8&=&[1,3,5,6,7,10,16,17]\\
B_9&=&[1,3,5,6,7,10,16,17,22]\\
B_{10}&=&[1,3,5,6,7,10,16,17,22,31]\\
\end{array}
\begin{array}{lll}
A_0&=&[5,31,7,1,6,17,16,22,3,10]\\
A_1&=&[5,31,7,6,17,16,22,3,10]\\
A_2&=&[5,31,7,6,17,16,22,10]\\
A_3&=&[31,7,6,17,16,22,10]\\
A_4&=&[31,7,17,16,22,10]\\
A_5&=&[31,17,16,22,10]\\
A_6&=&[31,17,16,22]\\
A_7&=&[31,17,22]\\
A_8&=&[31,22]\\
A_9&=&[31]\\
A_{10}&=&[\,]\\
\end{array}
\]
כדי להוכיח את הנכונות של מיון בחירה דרושות שתי למות. הראשונה זהה ללמה~1 הפשוטה של מיון הכנסה.

\begin{exercise}
נסח את הלמה השנייה הנחוצה להוכחת הנכונות של מיון בחירה. הוכח את הלמה.
\end{exercise}


\section{%
תכניות מקביליות%
}

בתכניות מקביליות מופיעות שגיאות מסוג הידוע לשמצה: שגיאות מירוץ. מהירויות ההרצה היחסיות של התהליכים יכולות לגרום לתקלות שכמעט בלתי אפשרי לשחזר אותן כדי לאתר את השגיאות ולבדוק אם תוקנו.
\textbf{סמפור}
הוא אמצעי סינכרון פשוט ויעיל שמאפשר לכתוב תכניות עם פחות שגיאות מירוץ. אנו מניחים שאתה בקיא בהגדרת הסמפור והפעולות עליו ומכיר את התכניות הפשוטה לפתרון בעיית הקטע הקריטי עם סמפור:

\selectlanguage{english}
\begin{center}
\begin{ttfamily}
\begin{tabular}{ll}
\multicolumn{2}{c}{global int sem = 1}\\
process p     & process q\\
\hspace*{2em}loop forever   & \hspace*{2em} loop forever\\
\hspace*{4em}p1: wait(sem)   &  \hspace*{4em}  q1: wait(sem)\\
\hspace*{4em}p2: critical section & \hspace*{4em} q2: critical section\\
\hspace*{4em}p3: signal(sem)  &\hspace*{4em}  q3: signal(sem)
\end{tabular}
\end{ttfamily}
\end{center}
\selectlanguage{hebrew}

טענת הנכונות היא שרק תהליך אחד נמצא בקטע הקריטי בבת-אחת.

הנוסחאות שלהלן הן
\textbf{שמורות},
כלומר, הן נכונות בכל מצב של כל חישוב:
\begin{eqnarray}
(\mathit{sem} = 0) \vee (\mathit{sem} = 1)&&\label{eq.sem01}\\
\#\mathit{CS} + \mathit{sem} = 1,&&\label{eq.sem}
\end{eqnarray}
כאשר
$\mathit{sem}$
הוא ערכו של המשתנה
\L{\texttt{sem}}
ו-%
$\#\mathit{CS}$
הוא מספר התהליכים בקטע הקריטי. התהליך 
\L{\texttt{p}}
נמצא בקטע הקריטי אם החישוב נמצא במקום
\L{\texttt{p2}}
או
\L{\texttt{p3}},
והתהליך
\L{\texttt{q}}
נמצא בקטע הקריטי אם החישוב נמצא במקום
\L{\texttt{q2}}
או
\L{\texttt{q3}}.

לפי נוסחה~%
\ref{eq.sem}, $\#\mathit{CS}= 1-\mathit{sem}$,
ולפי נוסחה~%
\ref{eq.sem01}:
\[(\#\mathit{CS}= 1-0) \vee (\#\mathit{CS}= 1-1),\]
כלומר,
$\#\mathit{CS} \leq 1$,
שהיא טענת הנכונות למניעה הדדית.

נוכיח את הנוסחה~%
\ref{eq.sem01}
באינדוקציה מעל למצבי החישוב.

טענת הבסיס פשוטה ביותר כי המשתנה
\L{\texttt{sem}}
מקבל ערך תחילי של
$1$.

קיימים
$18$
צעדי אינדוקציה!
\textbf{המיקום הנוכחי של החישוב}
הוא אחד מ-%
$9$
הזוגות:
\[(p_1,q_1), (p_1,q_2), (p_1,q_3), (p_2,q_1), (p_2,q_2), (p_2,q_3), (p_3,q_1), (p_3,q_2), (p_3,q_3),\]
ועבור כל אחד מהם, הפקודה הבאה יכולה לבוא או מתהליך
\L{\texttt{p}}
או מתהליך
\L{\texttt{q}}.
נבדוק שני צעדי אינדוקציה:

\begin{itemize}
\item
נניח שהחישוב נמצא במצב
$(p_1,q_1)$
והפקודה הבאה לביצוע היא
\L{\texttt{p1:wait(sem)}}.
הנחת האינדוקציה היא ש-%
)\ref{eq.sem01}(
נכונה. אם
$\mathit{sem} = 0$,
לפי ההגדרה, פעולת הסמפור
\L{\texttt{wait(sem)}}
לא ניתנת לביצוע כך ש-%
)\ref{eq.sem01}(
נשארת נכונה. אם
$\mathit{sem} = 1$,
לפי ההגדרה של פעולת המספור
\L{\texttt{wait(sem)}}
מחסירים
$1$
מערכו של
\L{\texttt{sem}},
כך ש-%
$\mathit{sem} = 0$
ו-%
)\ref{eq.sem01}(
נשארת נכונה.
\item
נניח שהחישוב נמצא ב-%
$(p_2,q_1)$
והפקודה הבאה לביצוע היא
\L{\texttt{p2:critical section}}.
הנחת האינדוקציה היא ש-%
)\ref{eq.sem01}(
נכונה. הפקודה
\L{\texttt{critical section}}
לא משנה את ערכו של
\L{\texttt{sem}}
כך ש-%
)\ref{eq.sem01}(
נשארת נכונה.
\end{itemize}
למרות שיש מספר רב של צעדי אינדוקציה, לרובם הוכחה פשוטה ביותר בגלל התכונה הלוגית של "גורר": ל-%
$A\rightarrow B$
ערך שקר אם ורק אם
$A$
מקבל ערך אמת ו-%
$B$
מקבל ערך שקר.

נבדוק את השמורה-%
\ref{eq.sem}
שהיא שקולה לשתי הנוסחאות:
\begin{eqnarray}
(p_1 \wedge q_1) &\rightarrow& (\mathit{sem} = 1)\label{eq.pqsem}\\
(\mathit{sem} = 1) &\rightarrow& (p_1 \wedge q_1)\label{eq.sempq}\,.
\end{eqnarray}
נוכיח את נוסחה~%
\ref{eq.pqsem}
באינדוקציה. טענת הבסיס נכונה בגלל האיתחול. הנחת האינדוקציה היא ש-%
)\ref{eq.pqsem}(
נכונה. יש שתי דרכים בהן הנוסחה יכולה לקבל ערך שקר:
\begin{enumerate}
\item
ל-%
$p_1 \wedge q_1$
ו-%
$\mathit{sem} = 1$
ערך אמת ואז הנוסחה
$\mathit{sem} = 1$
מקבלת ערך שקר בזמן ש-%
$p_1 \wedge q_1$
נשארת אמת.
\item
ל-%
$p_1 \wedge q_1$
ו-%
$\mathit{sem} = 1$
ערך שקר ואז הביטוי
$p_1 \wedge q_1$
מקבל ערך אמת בזמן ש-%
$\mathit{sem} = 1$
נשארת שקר.
\end{enumerate}
)1( הנוסחה 
$\mathit{sem} = 1$
מקבלת ערך שקר רק אם מבצעים
\L{\texttt{p1}}
או
\L{\texttt{q1}},
אבל אז גם הביטוי
$p_1 \wedge q_1$
מקבל שקר.\\
)2( הביטוי
$p_1 \wedge q_1$
מקבל אמת רק אם מבצעים
\L{\texttt{p3}}
או
\L{\texttt{q3}},
אבל אז גם הנוסחה
$\mathit{sem} = 1$
מקבלת אמת.

\begin{exercise}
הוכח נוסחה
~\ref{eq.sem}.
\end{exercise}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
